API:

COM(Component Object Model)架构

C++编译器本质上被设计得更适合用源代码进行软件组件复用而非从二进制文件上经行软件组件复用，因为不同的编译器可能会期待并编译出组织结构不同的二进制文件，从而导致C++的二进制库(`.lib`和`.dll`文件)在不同编译器间可能无法通用。

为了解决这个问题微软提出了COM标准

COM中的每一个接口通过GUID（Global Unique Identifier）表示，客户通过COM工厂函数，传入GUID获得创建COM对象，获得指向该对象的指针，通过指针调用该对象的其他成员函数，这样就算COM对象的类实现发生了变化，但是客户依旧可以用COM接口创建COM对象

在COM中所有的接口都是`IUnKnown`接口。对于每一个COM对象，可以用`AddRef()`和Release()方法来增加或减少对于该对象的应用数(即指向该对象的指针数)，同时，每一个COM对象都维持者一个对象引用数，当调用`AddRef`时引用数加1，调用Release时引用数减1，当引用数为0时，COM会销毁该COM对象

`IUnknown`接口还有一个方法名为`QueryInterface`。该方法接收一个GUID和一个指向指针的指针作为参数，如果该GUID有效，那么该方法接受的指针将会接收GUID所指的接口实例

D3D11

D3D11的API基于COM设计。在D3D11中想要创建任何渲染系统对象都需要通过ID3D11Device对象，该对象负责为渲染系统的其它部分（对象）分配资源，`IDXGISwapChain`对象负责把渲染信息呈现到显示器上，ID3D11DeviceContext负责将渲染数据并入渲染管线并对渲染管线进行控制

渲染管线

![DirecX11渲染管线](DirecX11渲染管线.png)

想要渲染图形，就得先渲染三角形。渲染三角形需要的数据有三角形在三维空间的顶点信息(x, y, z)(存储在Vertex Buffer中)，每个顶点的索引信息(储存在index buffer中，决定那些顶点组成一个三角面和三角面的朝向),其中有些信息需要传导至shader中,使用GPU进行图形渲染,这时需要指定GPU读取输入信息的方式,即Input Layout

raw input:



# 3D数学：

## 光照：

### 光照种类

#### 环境光(ambient light)：

之所以有环境光，不准确地说，是因为只要一个空间中有光源，那么这个光源所发出的光或多或少会反射到这个空间中的所有物体上，使他们不完全是一片黑色。在`hlsl`中若环境光颜色为la，物体对环境光的反射颜色为ma，则最终环境光分量呈现的颜色为
$$
A=la⊗ma = (la.r * ma.r, la.g * ma.g, la.b * ma.b)
$$
#### 漫反射（diffuse light）：

在现实生活中最常见的光。对于粗糙的表面，光照射在物体表面的一点后反射的方向是不确定的。这样人眼不管从哪个方向观察该点，呈现的亮度是不会变化的。但物体亮度与光照射向物体的方向有关，比如当均匀光线垂直照射物体的时候，此时看到的物体表面是最亮的；而均匀光线不经过物体表面，与表面平行的时候，物体的表面此时几乎是看不到的（此时可能仍有少量的光会到达物体表面，取决于光束的汇聚程度和与物体的距离）。毕竟光束不可能做到完全同一个方向照射，仍会有少数的散射光。

于是如果设光照方向向量为L，物体的法向量为n则对于一点的漫反射向量`Kd`来说
$$
Kd = max(L*n, 0)
$$
若漫反射光颜色向量为`ld`，物体材质对漫反射光的反射颜色向量为`md`，最终漫反射光分量呈现的颜色为:
$$
kd∗ld⊗md=KdD
$$
## 光照模型：

### 平行光/方向光：

平行光通常是一种全局光，它有一个固定的照射方向。

平行光照射下物体上一点的颜色信息为：
$$
litColor = A + KdD + KsS 
$$
其中`Kd` 和`Ks`的计算公式在上文已经给出

### 点光源：

点光是一种有源光照模型，确定光源位置后，它会朝所有方向辐射光照。

相比于方向光，点光源所散发出的光照的强度会随点光源和物体距离的拉远而衰减

点光源光照射下物体上一点的颜色信息为：
$$
litColor = (A + KdD +KsS)/attenuation, (attenuation = 1/(a + Ld + Qd^2))
$$
其中`d`表示点光源到物体上的对应顶点的距离`a、L、Q`为光强度衰减公式的参数

### 聚光灯：

聚光灯也是一种有源光照模型，在确定光源位置后，其照射区域可以看作一个锥体，在同等照射距离下，越靠近照射中心，亮度越强。同样随着距离的增大，光照强度逐渐减弱。

对于聚光灯的光照强度的因子`Kspot`
$$
Kspot = max(-L*d, 0)^s
$$
其中L为光线的方向向量，d为照射强度，s为光线的汇集程度

则经聚光灯照射下物体表面一点的亮度可以初步表示为：
$$
LitColor=kspot((A+kdD+ksS)/attenuation), (attenuation = 1/(a + Ld + Qd^2))
$$




投影：

根据小孔成像的原理，光屏距离小孔越远，或者物体离小孔越近，在光屏上呈的像越大（如下图所示），

![](1.PNG)

在计算机中，为了不使物体的投影翻转，我们可以假设，光屏在小孔的另一侧，保持Z方向上的固定距离Z'，物体与小孔的Z方向上的距离为变量Z，根据相似三角形原理，物体在光屏X轴、Y轴方向X‘，Y’上的投影位置应为物体在X轴、Y轴方向上的实际位置X、Y进行如下转换:										
$$
Y' = Y * Z' / Z
$$

$$
X'= X * Z'/Z
$$

在以下函数中Z‘被称为`NearZ`，Z被记为`FarZ`

通常我们希望投射空间中的顶点坐标，即经过以上处理的坐标，映射为NDC（normalize device coordinate），即X，Y，Z坐标映射到-1到1的范围内

对于一个顶点位置v = {x, y, z, 1},我们希望最终映射的NDC坐标v’
$$
v' = (v * PerspectiveMatrix)/ z
$$
其中v' = {x', y', z', 1},且x'，y‘随着`ViewWidth/2`和`ViewHeight/2`的增大而减小，随着`NearZ`的增大而增大（“光屏”的宽高越大，对应的FOV越大，x'，y'对应减小，`NearZ`越大，FOV越小）。对于z'来说,当z=`NearZ`时，z’ = 0；z = `FarZ`时，z‘ = 1；所以我们可以设`PerspectiveMatrix【3】【3】` = a，  `PerspectiveMatrix【3】【4】` = b，就可以得下式
$$
{a * NearZ + b = 0, a * FarZ + b = FarZ}
$$
由于最终的v‘结果还要将每个v坐标的元素除以z，因此第二个式子中的结果为`FarZ`

以下为伪代码

```C++
XMMatrix XMMatrixPerspectiveLH( 
	float ViewWidth, float ViewHeight, 
	float NearZ, float FarZ)
{
	return 
    {
        { 
            {2 * NearZ/ViewWidth, 0, 0, 0},
            {0, 2 * NearZ/ViewHeight, 0, 0},
            {0, 0, FarZ/(FarZ-NearZ), 1},
            {0, 0, -NearZ*FarZ/(FarZ-NearZ), 0}
        }
    }
}
```

Stencil:
Stencil::Mod::Off:不启用模板，启用深度

Stencil::Mod::Write:禁用深度，将VertexShader中的顶点信息写入模板缓存区中

Stencil::Mod::Mask:禁用深度，绘制时忽略模板缓存区中已被写入数据的对应像素
